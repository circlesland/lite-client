# A date and time value in JSON format.
scalar Date

type Server {
  version: String!
}

directive @cost(value: Int) on FIELD_DEFINITION

directive @costFactor(value: Int) on FIELD_DEFINITION

interface IAggregatePayload {
    lastUpdatedAt: String
}

enum ProfileType {
  PERSON
  ORGANISATION
  REGION
}

enum ProductListingType {
  TILES
  LIST
}

union AggregatePayload = Contacts | CrcBalances | Erc20Balances | Erc721Tokens | Members | Memberships | Offers | Purchases | Sales

type Profile {
  id: Int!
  type: ProfileType
  origin: ProfileOrigin
  status: String
  circlesAddress: String
  successorOfCirclesAddress: String
  circlesSafeOwner: String
  circlesTokenAddress: String
  displayName: String
  firstName: String!
  lastName: String
  emailAddress: String
  askedForEmailAddress: Boolean!
  dream: String
  country: String
  avatarUrl: String
  largeBannerUrl: String
  smallBannerUrl: String
  productListingType: ProductListingType
  avatarCid: String
  avatarMimeType: String
  newsletter: Boolean
  displayTimeCircles: Boolean
  cityGeonameid: Int
  city: City
  claimedInvitation: ClaimedInvitation
  invitationTransaction: ProfileEvent
  invitationLink: String
  memberships: [Membership!]
  members: [Profile!]
  displayCurrency: DisplayCurrency
  verifications: [Verification!]
  offers: [Offer!]
  purchases: [Purchase!]
  sales: [Sale!]
  balances: ProfileBalances
  contacts: [Contact!]
}

type City implements ICity {
  geonameid: Int!
  name: String!
  country: String!
  population: Int!
  latitude: Float!
  longitude: Float!
  feature_code: String!
}

type ClaimedInvitation {
  createdBy: Profile
  createdByProfileId: Int!
  createdAt: String!
  claimedBy: Profile
  claimedByProfileId: Int!
  claimedAt: String!
}

type ProfileEvent {
  timestamp: String!
  block_number: Int
  transaction_index: Int
  transaction_hash: String
  type: String!
  safe_address: String!
  safe_address_profile: Profile
  contact_address: String
  contact_address_profile: Profile
  direction: String!
  value: String
  payload: EventPayload
  tags: [Tag!]
}

type AnnouncePaymentResult {
    invoiceId: Int!
    pickupCode: String!
    simplePickupCode: String
    transactionHash: String!
}

enum DisplayCurrency {
  CRC
  TIME_CRC
  EURS
}

type Verification {
  createdAt: String!
  verifierSafeAddress: String!
  verifierProfile: Organisation
  verifiedSafeAddress: String!
  verifiedProfile: Profile
  revokedAt: String
  revokedProfile: Profile
  verificationRewardTransactionHash: String!
  verificationRewardTransaction: ProfileEvent
}

type Offer {
  id: Int!
  version: Int!
  createdByProfile: Profile
  createdByAddress: String!
  createdAt: String!
  title: String!
  pictureUrl: String!
  pictureMimeType: String!
  description: String
  pricePerUnit: String!
  timeCirclesPriceShare: Int!
  tags: [Tag!]
}

type Purchase {
  id: Int!
  createdByProfile: Profile
  createdByAddress: String!
  createdAt: String!
  total: String!
  lines: [PurchaseLine!]
  invoices: [Invoice!]
}

type Sale {
  id: Int!
  sellerAddress: String!
  sellerProfile: Profile
  buyerAddress: String!
  buyerProfile: Profile
  createdAt: String!
  total: String!
  lines: [SalesLine!]
  paymentTransaction: ProfileEvent
  invoices: [Invoice!]
}

type ProfileBalances {
  crcBalances: CrcBalances
  erc20Balances: Erc20Balances
}

type Contact {
  metadata: [ContactPoint!]!
  lastContactAt: String!
  contactAddress: String!
  contactAddress_Profile: Profile
}

type Contact {
    contactAddress: String!
    contactAddress_Profile: Profile
    lastContactAt: String!
    metadata: [ContactPoint!]!
}

type Organisation {
  id: Int!
  createdAt: String!
  circlesAddress: String
  circlesSafeOwner: String
  displayName: String
  name: String!
  description: String
  avatarUrl: String
  largeBannerUrl: String
  smallBannerUrl: String
  productListingType: ProductListingType
  avatarMimeType: String
  cityGeonameid: Int
  displayCurrency: DisplayCurrency
  city: City
  offers: [Offer!]
  members: [ProfileOrOrganisation!]
  shopEnabled: Boolean
  trustsYou: Int
}

union ProfileOrOrganisation = Profile | Organisation

input QueryUniqueProfileInput {
  id: Int!
}

input QueryProfileInput {
  id: [Int!]
  firstName: String
  lastName: String
  country: String
  circlesAddress: [String!]
}

input SearchInput {
  searchString: String!
}

input UpsertProfileInput {
  id: Int
  status: String!
  firstName: String!
  lastName: String
  dream: String
  country: String
  emailAddress: String
  askedForEmailAddress: Boolean
  successorOfCirclesAddress: String
  circlesAddress: String
  circlesSafeOwner: String
  circlesTokenAddress: String
  avatarUrl: String
  avatarCid: String
  avatarMimeType: String
  newsletter: Boolean
  displayTimeCircles: Boolean
  cityGeonameid: Int
  displayCurrency: DisplayCurrency
}

type Tag {
  id: Int!
  typeId: String!
  value: String
  order: Int
}

input CreateTagInput {
  typeId: String!
  value: String
}

input UpsertTagInput {
  id: Int
  typeId: String!
  value: String
}

type ExchangeTokenResponse {
  success: Boolean!
  errorMessage: String
}

type LogoutResponse {
  success: Boolean!
  errorMessage: String
}

type SessionInfo {
  isLoggedOn: Boolean!
  hasProfile: Boolean
  profileId: Int
  profile: Profile
  capabilities: [Capability!]!
}

type Capability {
  type: CapabilityType
}

type DeliveryMethod {
    id: Int!
    name: String!
}

type Erc20Balances implements IAggregatePayload {
    balances: [AssetBalance!]!
    lastUpdatedAt: String!
}

type RequestUpdateSafeResponse {
  success: Boolean!
  errorMessage: String
  challenge: String
}

type Erc721Token {
    token_address: String!
    token_name: String
    token_no: String!
    token_owner_address: String!
    token_owner_profile: Profile
    token_symbol: String
    token_url: String!
}

type Erc721Tokens implements IAggregatePayload {
    balances: [Erc721Token!]!
    lastUpdatedAt: String!
}

type EthTransfer implements IEventPayload {
    from: String!
    from_profile: Profile
    tags: [Tag!]!
    to: String!
    to_profile: Profile
    transaction_hash: String!
    value: String!
}

type UpdateSafeResponse {
  success: Boolean!
  errorMessage: String
  newSafeAddress: String
}

type FibonacciGoals {
    currentValue: Int!
    lastGoal: Int!
    nextGoal: Int!
}

type GnosisSafeEthTransfer implements IEventPayload {
    from: String!
    from_profile: Profile
    initiator: String!
    tags: [Tag!]!
    to: String!
    to_profile: Profile
    transaction_hash: String!
    value: String!
}

input QueryCitiesByGeonameIdInput {
  geonameid: [Int!]!
}

input QueryCitiesInput {
  byName: QueryCitiesByNameInput
  byId: QueryCitiesByGeonameIdInput
}

interface ICity {
  geonameid: Int!
  name: String!
  country: String!
  population: Int!
  latitude: Float!
  longitude: Float!
  feature_code: String!
}

type SalesLine {
  id: Int!
  amount: Int!
  offer: Offer!
}

type Invoice {
    buyerAddress: String!
    buyerProfile: Profile
    buyerSignature: Boolean
    buyerSignedDate: String
    cancelReason: String
    cancelledAt: String
    cancelledBy: Profile
    createdAt: String
    id: Int!
    invoiceNo: String!
    lines: [InvoiceLine!]
    paymentTransaction: ProfileEvent
    paymentTransactionHash: String
    pickupCode: String
    purchase: Purchase
    purchaseId: Int!
    sellerAddress: String!
    sellerProfile: Profile
    sellerSignature: Boolean
    sellerSignedDate: String
    simplePickupCode: String
}

type PurchaseLine {
  id: Int!
  amount: Int!
  offer: Offer
}

type InvoiceLine {
    amount: Int!
    id: Int!
    metadata: String
    offer: Offer
}

type LeaderboardEntry {
    createdByCirclesAddress: String!
    createdByProfile: Profile
    inviteCount: Int!
}

type LogoutResponse {
    errorMessage: String
    success: Boolean!
}

interface IEventPayload {
  transaction_hash: String
}

type CrcSignup implements IEventPayload {
  transaction_hash: String!
  user: String!
  user_profile: Profile
  token: String!
}

type CrcTrust implements IEventPayload {
  transaction_hash: String!
  address: String!
  address_profile: Profile
  can_send_to: String!
  can_send_to_profile: Profile
  limit: Int!
}

type Erc20Transfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  token: String!
  value: String!
}

type CrcTokenTransfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  token: String!
  value: String!
}

type CrcHubTransfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  flow: String!
  transfers: [CrcTokenTransfer!]!
  tags: [Tag!]!
}

type CrcMinting implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  value: String!
  token: String!
}

type Mutation {
    acceptMembership(membershipId: Int!): AcceptMembershipResult
    acknowledge(safeAddress: String, until: Date!): Boolean!
    addMember(groupId: String!, memberAddress: String!): AddMemberResult
    announcePayment(invoiceId: Int!, transactionHash: String!): AnnouncePaymentResult!
    claimInvitation(code: String!): ClaimInvitationResult!
    completePurchase(invoiceId: Int!, revoke: Boolean): Invoice!
    completeSale(invoiceId: Int!, revoke: Boolean): Invoice!
    createTestInvitation: CreateInvitationResult!
    deleteShippingAddress(id: Int!): PostAddress
    importOrganisationsOfAccount: [Organisation!]!
    logout: LogoutResponse!
    proofUniqueness(humanodeToken: String!): ProofUniquenessResult!
    purchase(deliveryMethodId: Int!, lines: [PurchaseLineInput!]!): [Invoice!]!
    redeemClaimedInvitation: RedeemClaimedInvitationResult!
    rejectMembership(membershipId: Int!): RejectMembershipResult
    removeMember(groupId: String!, memberAddress: String!): RemoveMemberResult
    requestSessionChallenge(address: String!): String!
    requestUpdateSafe(data: RequestUpdateSafeInput!): RequestUpdateSafeResponse!
    revokeSafeVerification(safeAddress: String!): VerifySafeResult!
    sendMessage(content: String!, fromSafeAddress: String, toSafeAddress: String!): SendMessageResult!
    tagTransaction(tag: CreateTagInput!, transactionHash: String!): TagTransactionResult!
    updateSafe(data: UpdateSafeInput!): UpdateSafeResponse!
    upsertOffer(offer: OfferInput!): Offer!
    upsertOrganisation(organisation: UpsertOrganisationInput!): CreateOrganisationResult!
    upsertProfile(data: UpsertProfileInput!): Profile!
    upsertRegion(organisation: UpsertOrganisationInput!): CreateOrganisationResult!
    upsertShippingAddress(data: PostAddressInput!): PostAddress
    upsertShop(shop: ShopInput!): Shop!
    upsertShopCategories(shopCategories: [ShopCategoryInput!]!): UpsertShopCategoriesResult!
    upsertShopCategoryEntries(shopCategoryEntries: [ShopCategoryEntryInput!]!): UpsertShopCategoryEntriesResult!
    upsertTag(data: UpsertTagInput!): Tag!
    verifySafe(safeAddress: String!): VerifySafeResult!
    verifySessionChallenge(challenge: String!, signature: String!): ExchangeTokenResponse
}

type MyInviteRank {
    rank: Int!
    redeemedInvitationsCount: Int!
}

type NewUser implements IEventPayload {
  transaction_hash: String
  profile: Profile!
}

type MembershipAccepted implements IEventPayload {
  transaction_hash: String
  createdBy: String!
  createdBy_profile: Profile
  member: String!
  member_profile: Profile
  organisation: String!
  organisation_profile: Organisation
}

type Offer {
    allergens: String
    createdAt: String!
    createdByAddress: String!
    createdByProfile: Profile
    description: String
    id: Int!
    pictureMimeType: String!
    pictureUrl: String!
    pricePerUnit: String!
    tags: [Tag!]
    timeCirclesPriceShare: Int!
    title: String!
    version: Int!
}

type InvitationCreated implements IEventPayload {
  transaction_hash: String
  name: String!
  code: String!
}

type Organisation {
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    circlesSafeOwner: String
    city: City
    cityGeonameid: Int
    createdAt: String!
    description: String
    displayCurrency: DisplayCurrency
    displayName: String
    id: Int!
    largeBannerUrl: String
    members: [ProfileOrOrganisation!]
    name: String!
    offers: [Offer!]
    productListingType: ProductListingType
    shopEnabled: Boolean
    shops: [Shop!]
    smallBannerUrl: String
    trustsYou: Int
}

type WelcomeMessage implements IEventPayload {
  transaction_hash: String
  invitedBy: String!
  invitedBy_profile: Profile
}

type PostAddress {
    city: String!
    cityGeonameid: Int
    country: String!
    house: String!
    id: Int!
    name: String
    state: String
    street: String!
    zip: String!
}

type Profile {
    askedForEmailAddress: Boolean!
    avatarCid: String
    avatarMimeType: String
    avatarUrl: String
    balances: ProfileBalances
    circlesAddress: String
    circlesSafeOwner: String
    circlesTokenAddress: String
    city: City
    cityGeonameid: Int
    claimedInvitation: ClaimedInvitation
    contacts: [Contact!]
    country: String
    displayCurrency: DisplayCurrency
    displayName: String
    displayTimeCircles: Boolean
    dream: String
    emailAddress: String
    firstName: String!
    id: Int!
    invitationLink: String
    invitationTransaction: ProfileEvent
    largeBannerUrl: String
    lastName: String
    members: [Profile!]
    memberships: [Membership!]
    newsletter: Boolean
    offers: [Offer!]
    origin: ProfileOrigin
    productListingType: ProductListingType
    purchases: [Purchase!]
    sales: [Sale!]
    shippingAddresses: [PostAddress!]
    shops: [Shop!]
    smallBannerUrl: String
    status: String
    successorOfCirclesAddress: String
    type: ProfileType
    verifications: [Verification!]
}

type SaleEvent implements IEventPayload {
  transaction_hash: String
  buyer: String!
  buyer_profile: Profile
  invoice: Invoice
}

type Purchased implements IEventPayload {
  transaction_hash: String
  seller: String!
  seller_profile: Profile
  purchase: Purchase!
}

type SafeVerified implements IEventPayload {
  transaction_hash: String
  organisation: String!
  organisation_profile: Organisation
  safe_address: String!
}

interface IAggregatePayload {
  lastUpdatedAt: String
}

type ProofUniquenessResult {
    existingSafe: String
}

type PublicEvent {
    block_number: Int
    contact_address: String
    contact_address_profile: Profile
    payload: EventPayload
    timestamp: String!
    transaction_hash: String
    transaction_index: Int
    type: String!
}

type Purchase {
    createdAt: String!
    createdByAddress: String!
    createdByProfile: Profile
    deliveryMethod: DeliveryMethod!
    id: Int!
    invoices: [Invoice!]
    lines: [PurchaseLine!]
    total: String!
}

type PurchaseLine {
    amount: Int!
    id: Int!
    metadata: String
    offer: Offer
}

type Offers implements IAggregatePayload {
  lastUpdatedAt: String!
  offers: [Offer!]!
}

type Purchases implements IAggregatePayload {
  lastUpdatedAt: String!
  purchases: [Purchase!]!
}

type Query {
    aggregates(filter: ProfileAggregateFilter, safeAddress: String!, types: [AggregateType!]!): [ProfileAggregate!]!
    cities(query: QueryCitiesInput!): [City!]!
    claimedInvitation: ClaimedInvitation
    clientAssertionJwt: String!
    commonTrust(safeAddress1: String!, safeAddress2: String!): [CommonTrust!]!
    directPath(amount: String!, from: String!, to: String!): TransitivePath!
    events(filter: ProfileEventFilter, pagination: PaginationArgs!, safeAddress: String!, types: [EventType!]!): [ProfileEvent!]!
    findInvitationCreator(code: String!): Profile
    findSafesByOwner(owner: String!): [SafeInfo!]!
    hubSignupTransaction: ProfileEvent
    init: SessionInfo!
    invitationTransaction: ProfileEvent
    invoice(invoiceId: Int!): String
    lastAcknowledgedAt(safeAddress: String!): Date
    myInvitations: [CreatedInvitation!]!
    myProfile: Profile
    offersByIdAndVersion(query: [OfferByIdAndVersionInput!]!): [Offer!]!
    organisations(pagination: PaginationArgs): [Organisation!]!
    organisationsByAddress(addresses: [String!]!): [Organisation!]!
    profilesById(ids: [Int!]!): [Profile!]!
    profilesBySafeAddress(safeAddresses: [String!]!): [Profile!]!
    recentProfiles(pagination: PaginationArgs): [Profile!]!
    regions(pagination: PaginationArgs): [Organisation!]!
    safeInfo(safeAddress: String): SafeInfo
    search(query: SearchInput!): [Profile!]!
    sessionInfo: SessionInfo!
    shop(id: Int!): Shop
    shops(ownerId: Int): [Shop!]!
    shopsById(ids: [Int!]!): [Shop!]!
    stats: Stats!
    tagById(id: Int!): Tag
    tags(query: QueryTagsInput!): [Tag!]!
    trustRelations(safeAddress: String!): [TrustRelation!]!
    verifications(filter: VerifiedSafesFilter, pagination: PaginationArgs): [Verification!]!
    version: Version!
}

union EventPayload =
    CrcSignup
  | CrcTrust
  | CrcTokenTransfer
  | CrcHubTransfer
  | CrcMinting
  | EthTransfer
  | Erc20Transfer
  | GnosisSafeEthTransfer
  | ChatMessage
  | MembershipOffer
  | MembershipAccepted
  | MembershipRejected
  | WelcomeMessage
  | InvitationCreated
  | InvitationRedeemed
  | OrganisationCreated
  | MemberAdded
  | SaleEvent
  | Purchased
  | SafeVerified
  | NewUser

enum EventType {
  CrcSignup
  CrcTrust
  CrcTokenTransfer
  CrcHubTransfer
  Erc20Transfer
  CrcMinting
  EthTransfer
  GnosisSafeEthTransfer
  ChatMessage
  MembershipOffer
  MembershipAccepted
  MembershipRejected
  WelcomeMessage
  InvitationCreated
  InvitationRedeemed
  OrganisationCreated
  MemberAdded
  SaleEvent
  Purchased
  SafeVerified
  NewUser
}

enum AggregateType {
  CrcBalances
  Erc20Balances
  Contacts
  Memberships
  Members
  Offers
  Purchases
  Sales
}

type AssetBalance {
  token_symbol: String
  token_address: String!
  token_owner_address: String!
  token_owner_profile: Profile
  token_balance: String!
}

enum ContactDirection {
  In
  Out
}

type ContactPoint {
  name: String!
  directions: [ContactDirection!]!
  values: [String!]!
  timestamps: [String!]!
}

union AggregatePayload =
    CrcBalances
  | Erc20Balances
  | Contacts
  | Memberships
  | Members
  | Offers
  | Sales
  | Purchases

type ProfileAggregate {
  type: String!
  safe_address: String!
  safe_address_profile: Profile
  payload: AggregatePayload!
}

type PublicEvent {
  timestamp: String!
  block_number: Int
  transaction_index: Int
  transaction_hash: String
  type: String!
  contact_address: String
  contact_address_profile: Profile
  payload: EventPayload
}

type NotificationEvent {
  type: String!
  from: String!
  to: String!
  itemId: Int
  transaction_hash: String
}

type CreatedInvitation {
  createdBy: Profile
  createdByProfileId: Int!
  createdAt: String!
  claimedBy: Profile
  claimedByProfileId: Int
  claimedAt: String
  name: String!
  address: String!
  balance: String!
  code: String!
}

type ClaimInvitationResult {
  success: Boolean!
  claimedInvitation: ClaimedInvitation
}

type SalesLine {
    amount: Int!
    id: Int!
    metadata: String
    offer: Offer!
}

type CreatedInviteEoa {
  for: String!
  address: String!
  fee: String!
}

type CreateInvitationResult {
  success: Boolean!
  error: String
  createdInviteEoas: [CreatedInvitation!]!
}

type SessionInfo {
    capabilities: [Capability!]!
    hasProfile: Boolean
    isLoggedOn: Boolean!
    profile: Profile
    profileId: Int
}

type Shop {
    categories: [ShopCategory!]
    createdAt: Date!
    deliveryMethods: [DeliveryMethod!]
    description: String!
    enabled: Boolean
    healthInfosLink: String
    id: Int!
    largeBannerUrl: String!
    name: String!
    openingHours: String
    owner: Organisation!
    ownerId: Int
    pickupAddress: PostAddress
    privacyPolicyLink: String
    private: Boolean
    productListingStyle: ProductListingType!
    purchaseMetaDataKeys: String
    shopListingStyle: ShopListingStyle!
    smallBannerUrl: String!
    sortOrder: Int
    tosLink: String
}

type ShopCategory {
    createdAt: Date
    description: String
    enabled: Boolean
    entries: [ShopCategoryEntry!]
    id: Int!
    largeBannerUrl: String
    name: String!
    private: Boolean
    productListingStyle: ProductListingType
    shop: Shop
    shopId: Int!
    smallBannerUrl: String
    sortOrder: Int
}

type ShopCategoryEntry {
    createdAt: Date!
    enabled: Boolean
    id: Int!
    private: Boolean
    product: Offer
    productId: Int!
    productVersion: Int!
    shopCategory: ShopCategory
    shopCategoryId: Int!
    sortOrder: Int
}

type Stats {
    goals: FibonacciGoals!
    leaderboard: [LeaderboardEntry!]!
    myRank: MyInviteRank!
    profilesCount: Int!
    verificationsCount: Int!
}

type TrustRelation {
  safeAddress: String!
  safeAddressProfile: Profile
  otherSafeAddress: String!
  otherSafeAddressProfile: Profile
  direction: TrustDirection!
}

type Tag {
    id: Int!
    order: Int
    typeId: String!
    value: String
}

type TagTransactionResult {
  success: Boolean!
  error: String
  tag: Tag
}

type CreateOrganisationResult {
  success: Boolean!
  error: String
  organisation: Organisation
}

input UpsertOrganisationInput {
  id: Int
  name: String!
  description: String
  circlesAddress: String
  avatarUrl: String
  largeBannerUrl: String
  smallBannerUrl: String
  productListingType: ProductListingType
  avatarMimeType: String
  cityGeonameid: Int
  displayCurrency: DisplayCurrency
}

type AddMemberResult {
  success: Boolean!
  error: String
}

type AcceptMembershipResult {
  success: Boolean!
  error: String
}

type UpsertShopCategoriesResult {
    inserted: Int!
    updated: Int!
}

type UpsertShopCategoryEntriesResult {
    inserted: Int!
    updated: Int!
}

type Verification {
    createdAt: String!
    revokedAt: String
    revokedProfile: Profile
    verificationRewardTransaction: ProfileEvent
    verificationRewardTransactionHash: String!
    verifiedProfile: Profile
    verifiedSafeAddress: String!
    verifierProfile: Organisation
    verifierSafeAddress: String!
}

type RemoveMemberResult {
  success: Boolean!
  error: String
}

input PurchaseLineInput {
  offerId: Int!
  amount: Int!
}

type ProofPaymentResult {
  acknowledged: Boolean!
}

type AnnouncePaymentResult {
  invoiceId: Int!
  transactionHash: String!
  pickupCode: String!
  simplePickupCode: String
}

enum AggregateType {
    Contacts
    CrcBalances
    Erc20Balances
    Erc721Tokens
    Members
    Memberships
    Offers
    Purchases
    Sales
}

enum CapabilityType {
    Invite
    PreviewFeatures
    Translate
    Verify
type i18n {
  lang: String
  key: String
  createdBy: String
  version: Int
  value: String
}

enum SortOrder {
  ASC
  DESC
}

input PaginationArgs {
  continueAt: String
  continueAtId: Int
  order: SortOrder!
  limit: Int!
}

enum Direction {
  in
  out
}

input PurchasedEventFilter {
  id: Int!
}

input SaleEventFilter {
  invoiceId: Int
  pickupCode: String
}

enum ProductListingType {
    LIST
    TILES
}

enum ProfileOrigin {
    CirclesGarden
    CirclesLand
    Unknown
}

input ProfileEventFilter {
  direction: Direction
  from: String
  to: String
  with: String
  transactionHash: String
  purchased: PurchasedEventFilter
  sale: SaleEventFilter
  chatMessage: ChatMessageEventFilter
}

enum ShopListingStyle {
    FEATURED
    REGULAR
}

enum SortOrder {
    ASC
    DESC
}

input CrcBalanceAggregateFilter {
  tokenAddresses: [String!]!
}

"A date and time value in JSON format."
scalar Date

input ChatMessageEventFilter {
    id: Int!
}

input PurchasesAggregateFilter {
  createdByAddresses: [String!]
  purchaseIds: [Int!]
  pickupCode: String
}

input SalesAggregateFilter {
  createdByAddresses: [String!]
  salesIds: [Int!]
  pickupCode: String
}

input ProfileAggregateFilter {
  contacts: ContactAggregateFilter
  crcBalance: CrcBalanceAggregateFilter
  offers: OffersAggregateFilter
  purchases: PurchasesAggregateFilter
  sales: SalesAggregateFilter
}

input OfferByIdAndVersionInput {
    offerId: Int!
    offerVersion: Int!
}

input OfferInput {
    allergens: String
    createdByProfileId: Int!
    description: String
    id: Int
    pictureMimeType: String!
    pictureUrl: String!
    pricePerUnit: String!
    timeCirclesPriceShare: Int!
    title: String!
}

input OffersAggregateFilter {
    createdByAddresses: [String!]
    offerIds: [Int!]
}

type SafeAddressByOwnerResult {
  type: String!
  safeAddress: String!
}

input PostAddressInput {
    cityGeonameid: Int!
    house: String!
    id: Int
    name: String
    street: String!
    zip: String!
}

input ProfileAggregateFilter {
    contacts: ContactAggregateFilter
    crcBalance: CrcBalanceAggregateFilter
    offers: OffersAggregateFilter
    purchases: PurchasesAggregateFilter
    sales: SalesAggregateFilter
}

input ProfileEventFilter {
    chatMessage: ChatMessageEventFilter
    direction: Direction
    from: String
    purchased: PurchasedEventFilter
    sale: SaleEventFilter
    to: String
    transactionHash: String
    with: String
}

input PurchaseLineInput {
    amount: Int!
    metadata: String
    offerId: Int!
}

type MyInviteRank {
  rank: Int!
  redeemedInvitationsCount: Int!
}

type Stats {
  profilesCount: Int!
  verificationsCount: Int!
  leaderboard: [LeaderboardEntry!]!
  goals: FibonacciGoals!
  myRank: MyInviteRank!
}

type TransitiveTransfer {
  from: String!
  to: String!
  token: String!
  tokenOwner: String!
  value: String!
}

type TransitivePath {
  requestedAmount: String!
  flow: String!
  transfers: [TransitiveTransfer!]!
}

type PostAddress {
  id: Int!
  name: String
  street: String!
  house: String!
  zip: String!
  state: String
  cityGeonameid: Int!
  city: City
}

input ShopInput {
  id: Int
  enabled: Boolean!
  private: Boolean
  name: String!
  description: String!
  largeBannerUrl: String!
  smallBannerUrl: String!
  shopListingStyle: ShopListingStyle!
  sortOrder: Int
  productListingStyle: ProductListingType!
  ownerId: Int!
  openingHours: String
}

type Shop {
  id: Int!
  createdAt: Date!
  private: Boolean
  name: String!
  description: String!
  largeBannerUrl: String!
  smallBannerUrl: String!
  shopListingStyle: ShopListingStyle!
  sortOrder: Int
  productListingStyle: ProductListingType!
  owner: Organisation!
  openingHours: String
  pickupAddress: PostAddress
  categories: [ShopCategory!]
}

type ShopCategory {
  id: Int!
  createdAt: Date
  shop: Shop
  shopId: Int!
  private: Boolean
  name: String!
  description: String
  largeBannerUrl: String
  smallBannerUrl: String
  sortOrder: Int
  productListingStyle: ProductListingType
  entries: [ShopCategoryEntry!]
}

input ShopCategoryInput {
  id: Int
  shopId: Int!
  private: Boolean
  name: String!
  description: String
  largeBannerUrl: String
  smallBannerUrl: String
  sortOrder: Int
  productListingStyle: ProductListingType
}

input SaleEventFilter {
    invoiceId: Int
    pickupCode: String
}

input SalesAggregateFilter {
    createdByAddresses: [String!]
    pickupCode: String
    salesIds: [Int!]
}

input ShopCategoryEntryInput {
  id: Int
  private: Boolean
  name: String
  shopCategoryId: Int!
  productId: Int!
  productVersion: Int!
  sortOrder: Int
}

input ShopCategoryEntryInput {
    enabled: Boolean
    id: Int
    name: String
    private: Boolean
    productId: Int!
    productVersion: Int!
    shopCategoryId: Int!
    sortOrder: Int
}

input ShopCategoryInput {
    description: String
    enabled: Boolean
    id: Int
    largeBannerUrl: String
    name: String!
    private: Boolean
    productListingStyle: ProductListingType
    shopId: Int!
    smallBannerUrl: String
    sortOrder: Int
}

input ShopInput {
    description: String!
    enabled: Boolean!
    healthInfosLink: String
    id: Int
    largeBannerUrl: String!
    name: String!
    openingHours: String
    ownerId: Int!
    privacyPolicyLink: String
    private: Boolean
    productListingStyle: ProductListingType!
    shopListingStyle: ShopListingStyle!
    smallBannerUrl: String!
    sortOrder: Int
    tosLink: String
}

input UpdateSafeInput {
    signature: String!
}

input UpsertOrganisationInput {
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    cityGeonameid: Int
    description: String
    displayCurrency: DisplayCurrency
    id: Int
    largeBannerUrl: String
    name: String!
    productListingType: ProductListingType
    smallBannerUrl: String
}

type Mutation {
  announcePayment(
    invoiceId: Int!
    transactionHash: String!
  ): AnnouncePaymentResult!
  purchase(lines: [PurchaseLineInput!]!): [Invoice!]!
  completePurchase(invoiceId: Int!, revoke: Boolean): Invoice!
  completeSale(invoiceId: Int!, revoke: Boolean): Invoice!
  logout: LogoutResponse!
  upsertProfile(data: UpsertProfileInput!): Profile!
  requestUpdateSafe(data: RequestUpdateSafeInput!): RequestUpdateSafeResponse!
  updateSafe(data: UpdateSafeInput!): UpdateSafeResponse!
  upsertTag(data: UpsertTagInput!): Tag!
  upsertOrganisation(
    organisation: UpsertOrganisationInput!
  ): CreateOrganisationResult!
  upsertRegion(
    organisation: UpsertOrganisationInput!
  ): CreateOrganisationResult!
  upsertShop(shop: ShopInput!): Shop!
  upsertShopCategories(
    shopCategories: [ShopCategoryInput!]!
  ): UpsertShopCategoriesResult!
  upsertShopCategoryEntries(
    shopCategoryEntries: [ShopCategoryEntryInput!]!
  ): UpsertShopCategoryEntriesResult!
  addMember(groupId: String!, memberAddress: String!): AddMemberResult
  acceptMembership(membershipId: Int!): AcceptMembershipResult
  removeMember(groupId: String!, memberAddress: String!): RemoveMemberResult
  rejectMembership(membershipId: Int!): RejectMembershipResult
  acknowledge(until: Date!, safeAddress: String): Boolean!
  requestInvitationOffer(for: String!): Offer!
  createTestInvitation: CreateInvitationResult!
  claimInvitation(code: String!): ClaimInvitationResult!
  redeemClaimedInvitation: RedeemClaimedInvitationResult!
  tagTransaction(
    transactionHash: String!
    tag: CreateTagInput!
  ): TagTransactionResult!
  sendMessage(
    fromSafeAddress: String
    toSafeAddress: String!
    content: String!
  ): SendMessageResult!
  requestSessionChallenge(address: String!): String!
  verifySessionChallenge(
    challenge: String!
    signature: String!
  ): ExchangeTokenResponse
  importOrganisationsOfAccount: [Organisation!]!
  verifySafe(safeAddress: String!): VerifySafeResult!
  revokeSafeVerification(safeAddress: String!): VerifySafeResult!
  updateValue(lang: String, key: String, createdBy: String, value: String): Int
  addNewLang(langToCreate: String, langToCopyFrom: String): Int
}

type Query {
  version: Version!
  sessionInfo: SessionInfo!
  init: SessionInfo!
  claimedInvitation: ClaimedInvitation
  invitationTransaction: ProfileEvent
  hubSignupTransaction: ProfileEvent
  safeInfo(safeAddress: String): SafeInfo
  lastAcknowledgedAt(safeAddress: String!): Date
  verifications(
    pagination: PaginationArgs
    filter: VerifiedSafesFilter
  ): [Verification!]!
  events(
    types: [EventType!]!
    safeAddress: String!
    pagination: PaginationArgs!
    filter: ProfileEventFilter
  ): [ProfileEvent!]!
  aggregates(
    types: [AggregateType!]!
    safeAddress: String!
    filter: ProfileAggregateFilter
  ): [ProfileAggregate!]!
  shops: [Shop!]!
  shop(id: Int!): Shop
  organisations(pagination: PaginationArgs): [Organisation!]!
  organisationsWithOffers: [Organisation!]!
  regions(pagination: PaginationArgs): [Organisation!]!
  organisationsByAddress(addresses: [String!]!): [Organisation!]!
  myInvitations: [CreatedInvitation!]!
  commonTrust(safeAddress1: String!, safeAddress2: String!): [CommonTrust!]!
  trustRelations(safeAddress: String!): [TrustRelation!]!
  myProfile: Profile
  profilesById(ids: [Int!]!): [Profile!]!
  recentProfiles(pagination: PaginationArgs): [Profile!]!
  profilesBySafeAddress(safeAddresses: [String!]!): [Profile!]!
  findSafesByOwner(owner: String!): [SafeInfo!]!
  search(query: SearchInput!): [Profile!]!
  stats: Stats!
  cities(query: QueryCitiesInput!): [City!]!
  tags(query: QueryTagsInput!): [Tag!]!
  tagById(id: Int!): Tag
  directPath(from: String!, to: String!, amount: String!): TransitivePath!
  invoice(invoiceId: Int!): String
  findInvitationCreator(code: String!): Profile
  getAllStrings: [i18n]
  getAllStringsByLanguage(lang: String): [i18n]
  getStringByLanguage(lang: String): [i18n!]
  getStringByMaxVersion(lang: String, key: String): i18n
  getAvailableLanguages: [i18n]
  getAllStringsByMaxVersion: [i18n]
  getOlderVersionsByKeyAndLang(key: String, lang: String): [i18n]
}

type Subscription {
  events: NotificationEvent!
}
